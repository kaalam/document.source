---
layout: post
title: How is Jazz a solution
description: What does Jazz provide that is truly hard in current platforms?
image: assets/images/top_solution.jpg
---
<div id="main" class="alt">
<section id="one">

<h4>Related pages</h4>
<ul class="actions vertical small">
	<li><a href="/kaalam/2018/10/02/reviewing_the_motive.html" class="button small">Part 1 the Motive for Jazz</a></li>
	<li><a href="/jazz_reference/vision_intro_page.html" class="button small">Technically, what is Jazz?</a></li>
</ul>


<p>

<h2>Our Purpose in 2016</h2><p>

<p>
<b>Jazz</b> was a tensor storage before it was cool. Back in 2016, we were motivated by the need for lightning-fast data retrieval in
backend applications, where every millisecond mattered. Our systems demanded not just efficient data storage but also robust backend
computation to process complex operations seamlessly. <b>Jazz</b> emerged as a solution to bridge these needs, combining speed and
computational capability in a way that felt ahead of its time.</p>

<h2>Bebop-25: Redefining Machine Understanding Through Iterative Execution</h2><p>

<p>
The transition to <b>Bebop-25</b> marked a pivotal moment for us, driven by the realization that true machine understanding required more
than conventional approaches to automated code generation. As <b>Jazz</b> evolved, becoming open source, we turned our focus to enabling
it to write, run, and evaluate code autonomously. This wasn’t about targeting traditional software development but fulfilling the
foundational need for machines to grasp and execute programs in ways that mirror human intent. Over time, the concept of Bebop, though
always carrying the same name, took on many iterations before solidifying as <b>Bebop-25</b>—a culmination of years of research
and discovery.</p>

<div class="row">
<div class="6u 12u$(small)">
<p>
Tackling the challenge of searching within the space of possible programs meant confronting a problem of combinatorial explosion. In this
quest, we encountered a need for something that simply did not exist. Reflecting on historical ingenuity, we drew inspiration from
<b>Antonio Gaud&iacute;</b>, the Spanish architect who designed the ambitious Sagrada Familia over a century ago. To calculate its complex
curves before the age of computers, he created an inverted physical model using strings and weighted bags, letting physics solve the
equations of his design. In a similar spirit, we realized that solving our problem required not just thinking outside the box but flipping
it upside down—embedding program execution as an integral part of the search process, rather than an isolated step that follows program
creation.</p>

<p>
This shift in thinking became the cornerstone of <b>Bebop-25</b>. By integrating execution into the search itself, we crafted a system that
could explore, test, and refine potential solutions in real-time, emulating a kind of <b>“live computation”</b>. This paradigm redefined how
we approached automated code generation and problem-solving, enabling us to move beyond static workflows to a dynamic, iterative process.
<b>Bebop-25</b> is more than just a system; it represents a philosophy of embracing unconventional approaches to drive innovation in machine
understanding.</p>

</div>
<div class="6u$ 12u$(small)">
<span class="image fit"><img src="/kaalam/assets/images/poly-funicular-miniature.png" alt="" /></span>
</div>
</div>

<p>
<b>Bebop-25</b> has <b>introspection and composition</b> at its core. By representing everything as a computational graph, it inherently
understands dependencies, enabling seamless transformations such as converting a method of a class into a standalone function or merging
multiple functions into a cohesive unit. This natural handling of dependencies extends beyond structure to behavior, making the system
remarkably adaptable. On top of this, the <b>resolver/compiler</b> paradigm empowers <b>Bebop-25</b> to compose code in a manner analogous
to how we construct natural language—blending smaller, meaningful units into larger, coherent expressions. This approach bridges the gap
between human intent and machine execution, making <b>Bebop-25</b> not only a tool but a true partner in problem-solving.</b>

<h2>Summarizing Jazz 1.25.x</h2><p>

</p>

<table>
  <thead>
    <tr>
      <th>Jazz is</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Native tensors and native tuples</b></td>
      <td>Built-in support for efficient data structures.</td>
    </tr>
    <tr>
      <td><b>Persistence</b></td>
      <td>Memory-mapped storage for high-performance data access.</td>
    </tr>
    <tr>
      <td><b>In RAM retrieval</b></td>
      <td>Uses optimized C structures for rapid data access.</td>
    </tr>
    <tr>
      <td><b>Data abstraction</b></td>
      <td>Spaces support, sharding, embeddings, time series, and more.</td>
    </tr>
    <tr>
      <td><b>Communication</b></td>
      <td>Integrates via bash, ZeroMQ and REST.</td>
    </tr>
    <tr>
      <td><b>Computation</b></td>
      <td>Leverages onnx-runtime for optimized execution. Compiled from Bebop-25 or written by Keras, Pytorch, ...</td>
    </tr>
    <tr>
      <td><b>Code generation</b></td>
      <td>Generates Bebop-25 automatically by a resolver, runs and evaluates.</td>
    </tr>
    <tr>
      <td><b>Monolith design</b></td>
      <td>An all-in-one C++ framework for comprehensive functionality.</td>
    </tr>
  </tbody>
</table>


<blockquote>
<b>Jazz</b> is a platform built for unmatched speed and innovation, with <b>code creation</b>, <b>introspection</b> and <b>composition</b>
embedded at its core. It redefines what’s possible, making it a foundation for the future of <b>intelligence engineering</b>.
</blockquote>
